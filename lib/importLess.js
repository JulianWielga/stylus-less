// Generated by CoffeeScript 1.10.0
(function() {
  var BaseVisitor, ExpressionVisitor, Plugin, Printer, TreeVisitor, crypto, exports, extend, fs, funcMap, genVar, importLess, isString, less, mixinMap, nodes, path, readLess, ref, renderMixinArg, renderMixinParam, renderPrelude, renderStylus, renderTree, renderValue, stylus, toUnquoted, utils,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  stylus = require('stylus');

  path = require('path');

  less = require('less');

  fs = require('fs');

  crypto = require('crypto');

  ref = require('underscore'), extend = ref.extend, isString = ref.isString;

  nodes = stylus.nodes;

  utils = stylus.utils;

  readLess = function(filename, callback) {
    var parser, str;
    parser = new less.Parser({
      filename: filename
    });
    str = fs.readFileSync(filename).toString();
    return parser.parse(str, function(err, node) {
      if (err) {
        console.log(str);
        throw err;
      }
      return callback(renderStylus(node));
    });
  };

  importLess = function(path) {
    path = path.toJSON().val;
    path = utils.lookup(path, this.options.paths);
    if (path) {
      return readLess(path, (function(_this) {
        return function(str) {
          var block, column, err, error, line, parser;
          block = new nodes.Block();
          parser = new stylus.Parser(str, utils.merge({
            root: block
          }, _this.options));
          try {
            block = parser.parse();
          } catch (error) {
            err = error;
            line = parser.lexer.prev.lineno;
            column = parser.lexer.prev.column;
            err.filename = file;
            err.lineno = line;
            err.column = column;
            err.input = str;
            throw err;
          }
          block = block.clone(_this.renderer.options.parent);
          block.parent = _this.renderer.options.parent;
          block.scope = false;
          return block.push(_this.visit(block));
        };
      })(this));
    }
  };

  Plugin = function(style) {
    style.include(__dirname);
    return style.define('importLess', importLess);
  };

  extend(Plugin, {
    path: __dirname,
    version: require(path.join(__dirname, '../package.json')).version
  });

  exports = module.exports = Plugin;

  BaseVisitor = (function() {
    function BaseVisitor() {}

    BaseVisitor.prototype.visitAlpha = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitAnonymous = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitAssigment = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitAttribute = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitCall = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitColor = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitComment = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitCondition = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitDimension = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitDirective = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitElement = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitExpression = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitExtend = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitImport = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitJavaScript = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitKeyword = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitMedia = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitMixin = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitMixinCall = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitMixinDefinition = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitNegative = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitOperation = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitParen = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitQuoted = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitRule = function(node, options) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitRuleset = function(node, options) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitSelector = function(node, options) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitValue = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitVariable = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitURL = function(node) {
      throw new Error('not implemented');
    };

    BaseVisitor.prototype.visitUnicodeDescriptor = function(node) {
      throw new Error('not implemented');
    };

    return BaseVisitor;

  })();

  genVar = function() {
    return "var" + (crypto.randomBytes(12).toString('hex'));
  };

  renderValue = function(node, options) {
    var impl, visitor;
    options = extend({}, options);
    if (isString(node)) {
      return node;
    }
    impl = new ExpressionVisitor;
    impl.options = options;
    visitor = new less.tree.visitor(impl);
    visitor.visit(node);
    if (impl.value) {
      return impl.value.trim();
    } else {
      return '';
    }
  };

  renderTree = function(printer, node, indent) {
    var impl;
    if (indent == null) {
      indent = '';
    }
    impl = new TreeVisitor(printer);
    impl.indent = indent;
    new less.tree.visitor(impl).visit(node);
    return impl;
  };

  renderMixinParam = function(node) {
    var param;
    param = node.name.slice(1);
    if (node.value) {
      return param = param + "=" + (renderValue(node.value));
    }
  };

  renderMixinArg = function(node) {
    var param;
    param = renderValue(node.value);
    if (node.name) {
      return param = (node.name.slice(1)) + "=" + param;
    }
  };

  renderPrelude = function() {
    return "lesscss-percentage(n)\n  (n * 100)%".trim();
  };

  renderStylus = function(node) {
    var printer;
    printer = new Printer();
    printer.add(renderPrelude());
    renderTree(printer, node);
    return printer.print();
  };

  toUnquoted = function(value) {
    return value.replace(/@{/g, '"@{').replace(/}/g, '}"').split(/(@{)|}/).filter(function(v) {
      return v !== '@{' && v !== '}' && (v != null ? v.length : void 0) > 0;
    }).join(' + ');
  };

  funcMap = {
    '%': 's',
    'percentage': 'lesscss-percentage'
  };

  mixinMap = {
    translate: 'mixin-translate',
    scale: 'mixin-scale',
    rotate: 'mixin-rotate',
    skew: 'mixin-skew',
    translate3d: 'mixin-translate3d'
  };

  Printer = (function() {
    function Printer() {}

    Printer.prototype.add = function(str) {
      if (this.data == null) {
        this.data = [];
      }
      return this.data.push(str);
    };

    Printer.prototype.print = function() {
      return this.data.join('\n');
    };

    return Printer;

  })();

  ExpressionVisitor = (function(superClass) {
    extend1(ExpressionVisitor, superClass);

    function ExpressionVisitor() {
      return ExpressionVisitor.__super__.constructor.apply(this, arguments);
    }

    ExpressionVisitor.prototype.acc = function(v) {
      if (!this.value) {
        this.value = '';
      }
      return this.value += ' ' + v;
    };

    ExpressionVisitor.prototype.visitAnonymous = function(node) {
      return this.acc(node.value);
    };

    ExpressionVisitor.prototype.visitDimension = function(node) {
      return this.acc("" + node.value + (node.unit.numerator.join('')));
    };

    ExpressionVisitor.prototype.visitVariable = function(node) {
      if (this.options.unquote) {
        return this.acc("@{" + (node.name.slice(1)) + "}");
      } else {
        return this.acc(node.name.slice(1));
      }
    };

    ExpressionVisitor.prototype.visitCall = function(node, options) {
      var args, name;
      options.visitDeeper = false;
      args = node.args.map((function(_this) {
        return function(e) {
          return renderValue(e, _this.options);
        };
      })(this)).join(', ');
      name = funcMap[node.name] || node.name;
      if (name === 's') {
        args = args.replace(/%d/g, '%s');
      }
      return this.acc(name + "(" + args + ")");
    };

    ExpressionVisitor.prototype.visitSelector = function(node, options) {
      var str;
      options.visitDeeper = false;
      str = node.elements.map((function(_this) {
        return function(e) {
          return "" + e.combinator.value + (renderValue(e, _this.options));
        };
      })(this)).join('').replace(/>/g, ' > ').replace(/\+/g, ' + ');
      return this.acc(str);
    };

    ExpressionVisitor.prototype.visitElement = function(node, options) {
      options.visitDeeper = false;
      return this.acc(renderValue(node.value, this.options));
    };

    ExpressionVisitor.prototype.visitAttribute = function(node, options) {
      var rendered;
      options.visitDeeper = false;
      rendered = node.key;
      if (node.op) {
        rendered += node.op + renderValue(node.value, this.options);
      }
      return this.acc("[" + rendered + "]");
    };

    ExpressionVisitor.prototype.visitKeyword = function(node) {
      return this.acc(node.value);
    };

    ExpressionVisitor.prototype.visitQuoted = function(node) {
      var value;
      if (node.escaped) {
        value = toUnquoted(node.value);
        return this.acc("unquote(" + node.quote + value + node.quote + ")");
      } else {
        return this.acc("" + node.quote + node.value + node.quote);
      }
    };

    ExpressionVisitor.prototype.visitParen = function(node, options) {
      options.visitDeeper = false;
      return this.acc("(" + (renderValue(node.value, this.options)) + ")");
    };

    ExpressionVisitor.prototype.visitRule = function(node, options) {
      options.visitDeeper = false;
      return this.acc(node.name + ": " + (renderValue(node.value, this.options)));
    };

    ExpressionVisitor.prototype.visitOperation = function(node, options) {
      var left, ref1, right, value;
      options.visitDeeper = false;
      if (node.operands.length !== 2) {
        throw new Error('assertion');
      }
      ref1 = node.operands, left = ref1[0], right = ref1[1];
      value = (renderValue(left, this.options)) + " " + node.op + " " + (renderValue(right, this.options));
      value = "(" + value + ")";
      return this.acc(value);
    };

    ExpressionVisitor.prototype.visitValue = function(node, options) {
      options.visitDeeper = false;
      return this.acc(node.value.map((function(_this) {
        return function(e) {
          return renderValue(e, _this.options);
        };
      })(this)).join(', '));
    };

    ExpressionVisitor.prototype.visitExpression = function(node, options) {
      options.visitDeeper = false;
      return this.acc(node.value.map((function(_this) {
        return function(e) {
          return renderValue(e, _this.options);
        };
      })(this)).join(' '));
    };

    ExpressionVisitor.prototype.visitColor = function(node) {
      var c;
      if (node.rgb) {
        c = "rgb(" + (node.rgb.join(', '));
        if (node.alpha) {
          c += ", " + node.alpha;
        }
        c += ")";
        return this.acc(c);
      } else {
        throw new Error("unknow color " + node);
      }
    };

    ExpressionVisitor.prototype.visitNegative = function(node) {
      return this.acc("- " + (renderValue(node.value, this.options)));
    };

    return ExpressionVisitor;

  })(BaseVisitor);

  TreeVisitor = (function(superClass) {
    extend1(TreeVisitor, superClass);

    TreeVisitor.prototype.indent = '';

    function TreeVisitor(printer1) {
      this.printer = printer1;
    }

    TreeVisitor.prototype.increaseIndent = function() {
      return this.indent + '  ';
    };

    TreeVisitor.prototype.decreaseIndent = function() {
      return this.indent.slice(0, -2);
    };

    TreeVisitor.prototype.p = function(m, indent) {
      indent = indent || this.indent;
      return this.printer.add("" + indent + (m.trim()));
    };

    TreeVisitor.prototype.isNamespaceDefinition = function(node) {
      var name;
      if (node.type !== 'Ruleset') {
        return false;
      }
      if (node.selectors.length !== 1) {
        return false;
      }
      name = renderValue(node.selectors[0]);
      if (name[0] !== '#') {
        return false;
      }
      if (!node.rules.every(function(rule) {
        return rule.type === 'MixinDefinition' || rule.type === 'Comment';
      })) {
        return false;
      }
      return name.slice(1);
    };

    TreeVisitor.prototype.isNamespaceCall = function(node) {};

    TreeVisitor.prototype.visitRuleset = function(node, options, directive) {
      var i, j, len, len1, namespace, ref1, ref2, res, results, rule, str;
      if (directive == null) {
        directive = '';
      }
      if (!node.root) {
        namespace = this.isNamespaceDefinition(node);
        options.visitDeeper = false;
        if (namespace) {
          ref1 = node.rules;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            rule = ref1[i];
            if (rule.type === 'MixinDefinition') {
              rule.name = "." + namespace + "-" + (rule.name.slice(1));
            }
            results.push(renderTree(this.printer, rule, this.indent));
          }
          return results;
        } else {
          if (node.rules.length > 0) {
            res = [];
            str = this.p("" + directive + (node.selectors.map(renderValue).join(', ')));
            res.push(str);
            ref2 = node.rules;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              rule = ref2[j];
              res.push(renderTree(this.printer, rule, this.increaseIndent()));
            }
            return res;
          }
        }
      }
    };

    TreeVisitor.prototype.visitRulesetOut = function(node) {
      if (!node.root) {
        return this.decreaseIndent();
      }
    };

    TreeVisitor.prototype.visitRule = function(node, options) {
      var name;
      options.visitDeeper = false;
      name = node.name;
      if (name[0] === '@') {
        return this.p((name.slice(1)) + " = " + (renderValue(node.value)));
      } else {
        return this.p(name + " " + (renderValue(node.value)) + node.important);
      }
    };

    TreeVisitor.prototype.visitComment = function(node) {
      if (!node.silent) {
        return this.p(node.value);
      }
    };

    TreeVisitor.prototype.visitMedia = function(node, options) {
      var features, i, len, mediaVar, ref1, results, rule;
      options.visitDeeper = false;
      features = renderValue(node.features, {
        unquote: true
      });
      if (/@{/.exec(features)) {
        mediaVar = genVar();
        this.p(mediaVar + " = \"" + (toUnquoted(features)) + "\"");
        this.p("@media " + mediaVar);
      } else {
        this.p("@media " + features);
      }
      ref1 = node.ruleset.rules;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        rule = ref1[i];
        results.push(renderTree(this.printer, rule, this.increaseIndent()));
      }
      return results;
    };

    TreeVisitor.prototype.visitSelector = function(node, options) {
      options.visitDeeper = false;
      return this.p(node.elements.map(renderValue).join(''));
    };

    TreeVisitor.prototype.visitMixinDefinition = function(node, options) {
      var i, len, name, ref1, rule;
      options.visitDeeper = false;
      name = node.name.slice(1);
      name = mixinMap[name] || name;
      this.p(name + "(" + (node.params.map(renderMixinParam).join(', ')) + ")");
      ref1 = node.rules;
      for (i = 0, len = ref1.length; i < len; i++) {
        rule = ref1[i];
        renderTree(this.printer, rule, this.increaseIndent());
      }
      if (node.params.length === 0 || node.params.every(function(p) {
        return p.value != null;
      })) {
        this.p("." + name);
        return this.p(name + "()", this.increaseIndent());
      }
    };

    TreeVisitor.prototype.visitMixinCall = function(node, options) {
      var name, namespace, v;
      options.visitDeeper = false;
      if (node.selector.elements.length === 2 && node.selector.elements[0].value[0] === '#') {
        namespace = node.selector.elements[0].value.slice(1);
        node.selector.elements[0] = node.selector.elements[1];
        delete node.selector.elements[1];
        node.selector.elements[0].value = namespace + "-" + (node.selector.elements[0].value.slice(1));
      }
      name = renderValue(node.selector).slice(1);
      name = mixinMap[name] || name;
      if (node["arguments"].length > 0) {
        v = "" + (renderValue(node.selector).slice(1));
        v += "(" + (node["arguments"].map(renderMixinArg).join(', ')) + ")";
      } else {
        v = "@extend ." + (renderValue(node.selector).slice(1));
      }
      return this.p(v);
    };

    TreeVisitor.prototype.visitImport = function(node, options) {
      options.visitDeeper = false;
      return this.p("@import " + (renderValue(node.path).replace(/\.less/, '.styl')));
    };

    TreeVisitor.prototype.visitDirective = function(node, options) {
      return this.visitRuleset(node.ruleset, options, node.name);
    };

    return TreeVisitor;

  })(BaseVisitor);

}).call(this);
